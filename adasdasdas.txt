QueueManagementSystem/
├── Controllers/
│   ├── CashController.cs
│   ├── LoanController.cs
│   ├── AccountSummaryController.cs
│   ├── QueueController.cs
│   └── TokenController.cs
├── Data/
│   ├── ApplicationDbContext.cs
│   ├── LoggingDbContext.cs
│   └── Migrations/
│       ├── <Auto-generated migration files>
├── Models/
│   ├── Customer.cs
│   ├── Token.cs
│   ├── LogEntry.cs
│   ├── QueueItem.cs
│   └── QueueStatus.cs
├── Services/
│   ├── MsmqService.cs
│   ├── TokenService.cs
│   ├── QueueProcessorService.cs
│   └── LoggerService.cs
├── Logging/
│   ├── Log4NetProvider.cs
│   └── Log4NetExtensions.cs
├── wwwroot/
│   └── <Static files if any>
├── appsettings.json
├── appsettings.Development.json
├── Program.cs
├── Startup.cs
├── log4net.config
└── QueueManagementSystem.csproj
File Contents
Controllers/QueueController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using QueueManagementSystem.Models;
using QueueManagementSystem.Services;
using System;
using System.Threading.Tasks;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class QueueController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly ILogger<QueueController> _logger;
        private readonly MsmqService _msmqService;

        public QueueController(ApplicationDbContext context, ILogger<QueueController> logger, MsmqService msmqService)
        {
            _context = context;
            _logger = logger;
            _msmqService = msmqService;
        }

        [HttpPost("request")]
        public async Task<IActionResult> RequestService([FromBody] Customer requestCustomer)
        {
            var token = TokenService.GenerateJwtToken(requestCustomer);
            requestCustomer.Token = token;
            requestCustomer.RequestTime = DateTime.UtcNow;

            var queueItem = new QueueItem
            {
                CustomerId = requestCustomer.Id,
                QueueTime = DateTime.UtcNow,
                ServiceRequested = requestCustomer.ServiceRequested,
                Priority = requestCustomer.Money, // Priority based on money
                Status = "Pending"
            };

            _context.QueueItems.Add(queueItem);
            await _context.SaveChangesAsync();

            _logger.LogInformation($"Customer {requestCustomer.Name} requested service {requestCustomer.ServiceRequested}. Token: {token}");

            await _msmqService.EnqueueAsync(requestCustomer.Id.ToString());

            return Ok(new { Token = token });
        }

        [HttpGet("status/{id}")]
        public async Task<IActionResult> GetStatus(int id)
        {
            var queueItem = await _context.QueueItems.FindAsync(id);
            if (queueItem == null) return NotFound();

            return Ok(queueItem);
        }
    }
}
Controllers/CashController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CashController : ControllerBase
    {
        private readonly ILogger<CashController> _logger;

        public CashController(ILogger<CashController> logger)
        {
            _logger = logger;
        }

        [HttpGet("process")]
        public IActionResult ProcessCash()
        {
            // Implement cash processing logic
            _logger.LogInformation("Cash processing started.");
            return Ok("Cash processing completed.");
        }
    }
}
Controllers/LoanController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class LoanController : ControllerBase
    {
        private readonly ILogger<LoanController> _logger;

        public LoanController(ILogger<LoanController> logger)
        {
            _logger = logger;
        }

        [HttpGet("apply")]
        public IActionResult ApplyForLoan()
        {
            // Implement loan application logic
            _logger.LogInformation("Loan application started.");
            return Ok("Loan application completed.");
        }
    }
}
Controllers/AccountSummaryController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AccountSummaryController : ControllerBase
    {
        private readonly ILogger<AccountSummaryController> _logger;

        public AccountSummaryController(ILogger<AccountSummaryController> logger)
        {
            _logger = logger;
        }

        [HttpGet("summary")]
        public IActionResult GetAccountSummary()
        {
            // Implement account summary retrieval logic
            _logger.LogInformation("Account summary retrieval started.");
            return Ok("Account summary retrieved.");
        }
    }
}
Controllers/TokenController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using QueueManagementSystem.Models;
using QueueManagementSystem.Services;
using System.Threading.Tasks;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TokenController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly TokenService _tokenService;

        public TokenController(ApplicationDbContext context, TokenService tokenService)
        {
            _context = context;
            _tokenService = tokenService;
        }

        [HttpPost("create")]
        public async Task<IActionResult> CreateToken([FromBody] Customer customer)
        {
            var token = _tokenService.GenerateJwtToken(customer);
            customer.Token = token;
            _context.Tokens.Add(new Token { Value = token, CustomerId = customer.Id });
            await _context.SaveChangesAsync();

            return Ok(new { Token = token });
        }
    }
}
Data/ApplicationDbContext.cs
csharp
Copy code
using Microsoft.EntityFrameworkCore;
using QueueManagementSystem.Models;

namespace QueueManagementSystem.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }

        public DbSet<Customer> Customers { get; set; }
        public DbSet<Token> Tokens { get; set; }
        public DbSet<LogEntry> Logs { get; set; }
        public DbSet<QueueItem> QueueItems { get; set; }
    }
}
Data/LoggingDbContext.cs
csharp
Copy code
using Microsoft.EntityFrameworkCore;
using QueueManagementSystem.Models;

namespace QueueManagementSystem.Data
{
    public class LoggingDbContext : DbContext
    {
        public LoggingDbContext(DbContextOptions<LoggingDbContext> options)
            : base(options)
        {
        }

        public DbSet<LogEntry> Logs { get; set; }
    }
}
Models/Customer.cs
csharp
Copy code
public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Money { get; set; }
    public string Token { get; set; }
    public DateTime RequestTime { get; set; }
    public string ServiceRequested { get; set; }
}
Models/Token.cs
csharp
Copy code
public class Token
{
    public int Id { get; set; }
    public string Value { get; set; }
    public int CustomerId { get; set; }
}
Models/LogEntry.cs
csharp
Copy code
public class LogEntry
{
    public int Id { get; set; }
    public DateTime Timestamp { get; set; }
    public string Message { get; set; }
}
Models/QueueItem.cs
csharp
Copy code
public class QueueItem
{
    public int Id { get; set; }
    public int CustomerId { get; set; }
    public DateTime QueueTime { get; set; }
    public string ServiceRequested { get; set; }
    public decimal Priority { get; set; } // Priority based on money
    public string Status { get; set; } // Status of the queue item
}
Models/QueueStatus.cs
csharp
Copy code
public class QueueStatus
{
    public int CustomerId { get; set; }
    public string Status { get; set; }
    public DateTime UpdatedAt { get; set; }
}
Services/MsmqService.cs
csharp
Copy code
using System.Messaging;
using System.Threading.Tasks;

namespace QueueManagementSystem.Services
{
    public class MsmqService
    {
        private readonly string _queuePath = @".\private$\queue";

        public MsmqService()
        {
            if (!MessageQueue.Exists(_queuePath))
            {
                MessageQueue.Create(_queuePath);
            }
        }

        public async Task EnqueueAsync(string message)
        {
            using var queue = new MessageQueue(_queuePath);
            queue.Formatter = new XmlMessageFormatter(new[] { "System.String,mscorlib" });
            await Task.Run(() => queue.Send(message));
        }
    }
}
Services/TokenService.cs
csharp
Copy code
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace QueueManagementSystem.Services
{
    public class TokenService
    {
        private const string SecretKey = "your_secret_key"; // Change this to your actual secret key
        private const string Issuer = "your_issuer";

        public string GenerateJwtToken(Customer customer)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(SecretKey);
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(new[]
                {
                    new Claim(ClaimTypes.Name, customer.Name),
                    new Claim(ClaimTypes.NameIdentifier, customer.Id.ToString())
                }),
                Expires = DateTime.UtcNow.AddHours(1),
                Issuer = Issuer,
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }
    }
}
Services/QueueProcessorService.cs
csharp
Copy code
using QueueManagementSystem.Data;
using QueueManagementSystem.Models;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace QueueManagementSystem.Services
{
    public class QueueProcessorService
    {
        private readonly ApplicationDbContext _context;

        public QueueProcessorService(ApplicationDbContext context)
        {
            _context = context;
        }

        public async Task ProcessQueueAsync()
        {
            while (true)
            {
                var currentTime = DateTime.UtcNow;

                // Get all pending queue items, ordered by priority (money) and then by queue time
                var queueItems = _context.QueueItems
                    .Where(q => q.Status == "Pending" && (currentTime - q.QueueTime).TotalMinutes >= 1)
                    .OrderByDescending(q => q.Priority)
                    .ThenBy(q => q.QueueTime)
                    .ToList();

                foreach (var item in queueItems)
                {
                    // Update queue item status to "Processing"
                    item.Status = "Processing";
                    _context.QueueItems.Update(item);
                    await _context.SaveChangesAsync();

                    // Simulate processing (e.g., handle the request)
                    await Task.Delay(1000);

                    // Mark as completed
                    item.Status = "Completed";
                    _context.QueueItems.Update(item);
                    await _context.SaveChangesAsync();
                }

                await Task.Delay(TimeSpan.FromSeconds(10)); // Delay before next processing cycle
            }
        }
    }
}
Services/LoggerService.cs
csharp
Copy code
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Services
{
    public class LoggerService
    {
        private readonly ILogger<LoggerService> _logger;

        public LoggerService(ILogger<LoggerService> logger)
        {
            _logger = logger;
        }

        public void LogInfo(string message)
        {
            _logger.LogInformation(message);
        }

        public void LogError(string message)
        {
            _logger.LogError(message);
        }
    }
}
Logging/Log4NetProvider.cs
csharp
Copy code
using Microsoft.Extensions.Logging;
using log4net;

namespace QueueManagementSystem.Logging
{
    public class Log4NetProvider : ILoggerProvider
    {
        private readonly ILog _log = LogManager.GetLogger(typeof(Log4NetProvider));

        public ILogger CreateLogger(string categoryName)
        {
            return new Log4NetLogger(_log);
        }

        public void Dispose() { }
    }
}
Logging/Log4NetExtensions.cs
csharp
Copy code
using Microsoft.Extensions.DependencyInjection;

namespace QueueManagementSystem.Logging
{
    public static class Log4NetExtensions
    {
        public static IServiceCollection AddLog4Net(this IServiceCollection services)
        {
            services.AddSingleton<ILoggerProvider, Log4NetProvider>();
            return services;
        }
    }
}
appsettings.json
json
Copy code
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=QueueManagement;Trusted_Connection=True;MultipleActiveResultSets=true",
    "LoggingConnection": "Server=(localdb)\\mssqllocaldb;Database=Logging;Trusted_Connection=True;MultipleActiveResultSets=true"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning"
    }
  },
  "AllowedHosts": "*"
}
appsettings.Development.json
json
Copy code
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft": "Debug"
    }
  }
}
Program.cs
csharp
Copy code
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;

namespace QueueManagementSystem
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
    }
}
Startup.cs
csharp
Copy code
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using QueueManagementSystem.Data;
using QueueManagementSystem.Logging;
using QueueManagementSystem.Services;

namespace QueueManagementSystem
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();
            services.AddDbContext<ApplicationDbContext>(options =>
                options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
            services.AddDbContext<LoggingDbContext>(options =>
                options.UseSqlServer(Configuration.GetConnectionString("LoggingConnection")));

            services.AddSingleton<MsmqService>();
            services.AddSingleton<TokenService>();
            services.AddSingleton<QueueProcessorService>();
            services.AddSingleton<LoggerService>();

            services.AddLog4Net();

            services.AddSwaggerGen(c =>
            {
                c.SwaggerDoc("v1", new OpenApiInfo { Title = "Queue Management API", Version = "v1" });
            });
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI(c =>
                {
                    c.SwaggerEndpoint("/swagger/v1/swagger.json", "Queue Management API V1");
                    c.RoutePrefix = string.Empty; // Set Swagger UI at the app's root
                });
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                app.UseHsts();
            }

            app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
    }
}
log4net.config
xml
Copy code
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender">
    <file value="logfile.txt" />
    <appendToFile value="true" />
    <rollingStyle value="Size" />
    <maxSizeRollBackups value="10" />
    <staticLogFileName value="true" />
    <layout type="log4net.Layout.PatternLayout">
      <conversionPattern value="%date [%thread] %-5level %logger - %message%newline" />
    </layout>
  </appender>
  <root>
    <level value="DEBUG" />
    <appender-ref ref="RollingFileAppender" />
  </root>
</configuration>
Testing the API
To test the API:

Run the Application:

Use dotnet run to start your application.
Use Swagger UI:

Navigate to http://localhost:5000 to access Swagger UI.
Use Postman:

Test endpoints using Postman as described previously.
Use cURL:

Send HTTP requests with cURL to verify API functionality.
Write Unit Tests:

Implement automated tests for your API using xUnit or another testing framework.
By following these steps and using the provided file structure, you should have a functioning queue management system that handles prioritization and reporting status effectively.

where log will be stored
ChatGPT
In the provided setup, logs are configured to be stored in a file using Log4Net. Specifically, the logs will be saved in a file named logfile.txt. Here’s where and how you can find and manage these logs:

Log Storage Configuration
log4net.config
In your log4net.config file, the log settings are defined. The crucial parts of this configuration are:

xml
Copy code
<appender name="RollingFileAppender" type="log4net.Appender.RollingFileAppender">
    <file value="logfile.txt" />
    <appendToFile value="true" />
    <rollingStyle value="Size" />
    <maxSizeRollBackups value="10" />
    <staticLogFileName value="true" />
    <layout type="log4net.Layout.PatternLayout">
      <conversionPattern value="%date [%thread] %-5level %logger - %message%newline" />
    </layout>
</appender>
<file value="logfile.txt" />: This specifies that the log file will be named logfile.txt. It will be created in the root directory of your application (where your application is executed).

<appendToFile value="true" />: This indicates that log entries will be appended to the file rather than overwriting it.

<rollingStyle value="Size" />: This setting ensures that the log file will roll over based on its size. Once the log file reaches the size specified, it will roll over and create a new file.

<maxSizeRollBackups value="10" />: This specifies the maximum number of backup files to keep. If the log file reaches the maximum size, older backups will be deleted once the number of backups exceeds this limit.

<staticLogFileName value="true" />: Ensures that the log file name remains static and doesn’t change when rolling over.

Where to Find the Log File
Root Directory: By default, logfile.txt will be stored in the root directory of your application where you execute it. If you run your application from a directory like C:\Projects\QueueManagementSystem, the log file will be in that directory.

Custom Paths: If you want to store the logs in a different directory, you can update the <file value="path_to_logfile" /> attribute in the log4net.config file to a specific path, such as:

xml
Copy code
<file value="C:\\Logs\\queue_management_system_log.txt" />
Accessing and Managing Logs
Navigate to the File Location: Use File Explorer or a command-line tool to navigate to the directory where logfile.txt is located.

Open the Log File: Use any text editor (e.g., Notepad, Visual Studio Code) to open and view the log file.

Monitor Logs: You can also use command-line tools to monitor the log file in real-time, such as tail on Unix-based systems:

bash
Copy code
tail -f logfile.txt
Adjust Log Settings: If you need to change logging behavior, such as the file path or rolling settings, you can modify the log4net.config file and restart your application for the changes to take effect.

By configuring your logging as shown, you ensure that logs are well-managed and stored appropriately for later review and debugging.

how to test the api
ChatGPT
To test the API effectively, you can use several methods, including manual testing with tools like Swagger UI and Postman, as well as automated testing with unit tests. Here’s a detailed guide on each method:

1. Manual Testing with Swagger UI
Swagger UI provides a web-based interface to test your API endpoints interactively.

Run Your Application:

Ensure your application is running. Typically, you can start it using dotnet run if you're using .NET Core or by running the application from Visual Studio.
Access Swagger UI:

Open a web browser and navigate to http://localhost:5000 or https://localhost:5001 (depending on your configuration). You should see the Swagger UI interface.
Test Endpoints:

Find the endpoint you want to test in the Swagger UI.
Click on the endpoint to expand it.
Enter the required parameters and click the “Try it out” button.
Review the response to ensure the API behaves as expected.
2. Manual Testing with Postman
Postman is a popular tool for testing APIs. Here’s how you can use it:

Download and Install Postman:

Download Postman and install it on your machine.
Create a New Request:

Open Postman and click “New” to create a new request.
Choose “Request” and enter a name for your request.
Configure the Request:

Set the request method (GET, POST, PUT, DELETE) according to the endpoint you’re testing.
Enter the URL of your API endpoint (e.g., http://localhost:5000/api/queue/request).
If the endpoint requires a body (e.g., POST request), select the “Body” tab and enter the JSON payload.
Send the Request:

Click the “Send” button to make the request.
Review the response status, headers, and body to verify that the API is working as intended.
Save and Organize Requests:

Save your requests in collections for organized testing and reuse.
3. Automated Testing with Unit Tests
Automated unit tests ensure that your API works correctly and helps in detecting issues early.

Set Up a Testing Project:

Create a new testing project in your solution, typically using xUnit or NUnit.
Add a reference to your API project.
Write Unit Tests:

Use the testing framework to write test cases for your API controllers and services.
Example Using xUnit:
Install xUnit:

Add xUnit and the xUnit runner package via NuGet:
bash
Copy code
dotnet add package xunit
dotnet add package xunit.runner.visualstudio
Write a Test:

QueueControllerTests.cs

csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using QueueManagementSystem.Controllers;
using QueueManagementSystem.Models;
using QueueManagementSystem.Services;
using Xunit;

namespace QueueManagementSystem.Tests
{
    public class QueueControllerTests
    {
        private readonly QueueController _controller;
        private readonly Mock<ApplicationDbContext> _mockContext;
        private readonly Mock<MsmqService> _mockMsmqService;

        public QueueControllerTests()
        {
            _mockContext = new Mock<ApplicationDbContext>(new DbContextOptions<ApplicationDbContext>());
            _mockMsmqService = new Mock<MsmqService>();
            _controller = new QueueController(_mockContext.Object, Mock.Of<ILogger<QueueController>>(), _mockMsmqService.Object);
        }

        [Fact]
        public async Task RequestService_ShouldReturnOkResult()
        {
            // Arrange
            var customer = new Customer { Id = 1, Name = "John Doe", Money = 1000, ServiceRequested = "Cash" };

            // Act
            var result = await _controller.RequestService(customer);

            // Assert
            var actionResult = Assert.IsType<OkObjectResult>(result);
            Assert.NotNull(actionResult.Value);
        }
    }
}
Run Tests:
Execute your tests using Visual Studio’s Test Explorer or by running dotnet test in the command line.
4. Command-Line Testing with cURL
cURL is a command-line tool for making HTTP requests.

Send a GET Request:

bash
Copy code
curl -X GET http://localhost:5000/api/queue/status/1
Send a POST Request:

bash
Copy code
curl -X POST http://localhost:5000/api/queue/request -H "Content-Type: application/json" -d '{"Name":"John Doe","Money":1000,"ServiceRequested":"Cash"}'
Review Responses:

Check the response in the terminal to ensure it matches expected results.
By using these methods, you can thoroughly test your API to ensure it behaves as expected and handles various scenarios correctly.

give me the api samples 
ChatGPT
Sure! Below are sample API requests for testing the different endpoints in your queue management system. These examples cover CRUD operations and other functionalities based on the controllers and logic you've implemented.

1. Request Service (POST)
This endpoint allows a customer to request a service, generating a token and adding them to the queue.

Endpoint:

arduino
Copy code
POST /api/queue/request
Request Body:

json
Copy code
{
  "Name": "John Doe",
  "Money": 1000,
  "ServiceRequested": "Cash"
}
cURL Command:

bash
Copy code
curl -X POST http://localhost:5000/api/queue/request \
-H "Content-Type: application/json" \
-d '{"Name":"John Doe","Money":1000,"ServiceRequested":"Cash"}'
Expected Response:

json
Copy code
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "queuePosition": 1
}
2. Check Token Status (GET)
This endpoint allows you to check the status of a request using a token.

Endpoint:

bash
Copy code
GET /api/token/status/{token}
cURL Command:

bash
Copy code
curl -X GET http://localhost:5000/api/token/status/{token}
Expected Response:

json
Copy code
{
  "Token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "QueuePosition": 1,
  "Status": "Pending"
}
3. Cash Service (GET)
This endpoint provides the cash service.

Endpoint:

bash
Copy code
GET /api/cash
cURL Command:

bash
Copy code
curl -X GET http://localhost:5000/api/cash
Expected Response:

json
Copy code
{
  "Service": "Cash",
  "Message": "Cash service available."
}
4. Loan Service (GET)
This endpoint provides the loan service.

Endpoint:

bash
Copy code
GET /api/loan
cURL Command:

bash
Copy code
curl -X GET http://localhost:5000/api/loan
Expected Response:

json
Copy code
{
  "Service": "Loan",
  "Message": "Loan service available."
}
5. Account Summary Service (GET)
This endpoint provides the account summary service.

Endpoint:

bash
Copy code
GET /api/accountsummary
cURL Command:

bash
Copy code
curl -X GET http://localhost:5000/api/accountsummary
Expected Response:

json
Copy code
{
  "Service": "AccountSummary",
  "Message": "Account summary service available."
}
6. Get Queue Status (GET)
This endpoint provides the status of the queue.

Endpoint:

arduino
Copy code
GET /api/queue/status
cURL Command:

bash
Copy code
curl -X GET http://localhost:5000/api/queue/status
Expected Response:

json
Copy code
[
  {
    "CustomerId": 1,
    "Name": "John Doe",
    "ServiceRequested": "Cash",
    "QueuePosition": 1,
    "Status": "Processing"
  }
]
7. Update Queue Status (PUT)
This endpoint updates the status of a queue item.

Endpoint:

bash
Copy code
PUT /api/queue/status/{id}
Request Body:

json
Copy code
{
  "Status": "Completed"
}
cURL Command:

bash
Copy code
curl -X PUT http://localhost:5000/api/queue/status/1 \
-H "Content-Type: application/json" \
-d '{"Status":"Completed"}'
Expected Response:

json
Copy code
{
  "CustomerId": 1,
  "Name": "John Doe",
  "ServiceRequested": "Cash",
  "QueuePosition": 1,
  "Status": "Completed"
}
8. Delete Queue Item (DELETE)
This endpoint deletes a queue item.

Endpoint:

bash
Copy code
DELETE /api/queue/status/{id}
cURL Command:

bash
Copy code
curl -X DELETE http://localhost:5000/api/queue/status/1
Expected Response:

json
Copy code
{
  "message": "Queue item deleted successfully."
}
9. Swagger Documentation (GET)
To view the Swagger documentation and test the API interactively:

Endpoint:

bash
Copy code
GET /swagger
cURL Command:

bash
Copy code
curl -X GET http://localhost:5000/swagger
You can also view Swagger UI in your browser at http://localhost:5000 or https://localhost:5001 to interactively test all endpoints.

These sample API requests cover the basic functionality of your queue management system. Adjust the URLs and request bodies as needed based on your actual implementation and configuration.