QueueManagementSystem/
│
├── Controllers/
│   ├── CashController.cs
│   ├── LoanController.cs
│   ├── AccountSummaryController.cs
│   ├── QueueController.cs
│   └── TokenController.cs
│
├── Data/
│   ├── ApplicationDbContext.cs
│   ├── LoggingDbContext.cs
│   └── Migrations/
│       ├── <Auto-generated migration files>
│
├── Models/
│   ├── Customer.cs
│   ├── Token.cs
│   ├── LogEntry.cs
│   ├── QueueItem.cs
│   └── QueueStatus.cs
│
├── Services/
│   ├── MsmqService.cs
│   ├── TokenService.cs
│   ├── QueueProcessorService.cs
│   └── LoggerService.cs
│
├── Logging/
│   ├── Log4NetProvider.cs
│   ├── Log4NetLogger.cs
│   └── Log4NetExtensions.cs
│
├── wwwroot/
│   └── <Static files if any>
│
├── appsettings.json
├── appsettings.Development.json
├── Program.cs
├── Startup.cs
├── log4net.config
├── QueueManagementSystem.csproj
└── README.md
1. Controllers
CashController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CashController : ControllerBase
    {
        private readonly ILogger<CashController> _logger;

        public CashController(ILogger<CashController> logger)
        {
            _logger = logger;
        }

        [HttpPost("process")]
        public IActionResult ProcessCash([FromBody] CashRequest request)
        {
            // Process cash logic here
            _logger.LogInformation("Cash processing started for customer {CustomerId}.", request.CustomerId);
            // Assume success
            return Ok(new { Status = "Completed", Message = "Cash processed successfully." });
        }
    }

    public class CashRequest
    {
        public int CustomerId { get; set; }
        public decimal Amount { get; set; }
    }
}
LoanController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class LoanController : ControllerBase
    {
        private readonly ILogger<LoanController> _logger;

        public LoanController(ILogger<LoanController> logger)
        {
            _logger = logger;
        }

        [HttpPost("apply")]
        public IActionResult ApplyForLoan([FromBody] LoanRequest request)
        {
            // Apply for loan logic here
            _logger.LogInformation("Loan application started for customer {CustomerId}.", request.CustomerId);
            // Assume success
            return Ok(new { Status = "Completed", Message = "Loan application processed successfully." });
        }
    }

    public class LoanRequest
    {
        public int CustomerId { get; set; }
        public decimal LoanAmount { get; set; }
    }
}
AccountSummaryController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AccountSummaryController : ControllerBase
    {
        private readonly ILogger<AccountSummaryController> _logger;

        public AccountSummaryController(ILogger<AccountSummaryController> logger)
        {
            _logger = logger;
        }

        [HttpGet("summary")]
        public IActionResult GetAccountSummary([FromQuery] int customerId)
        {
            // Get account summary logic here
            _logger.LogInformation("Account summary retrieval started for customer {CustomerId}.", customerId);
            // Assume success
            return Ok(new 
            { 
                CustomerId = customerId,
                Name = "John Doe", // Example data
                Balance = 10000.0, // Example data
                LoanAmount = 50000.0, // Example data
                QueueStatus = "Completed" // Example data
            });
        }
    }
}
QueueController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using QueueManagementSystem.Models;
using QueueManagementSystem.Services;
using System.Threading.Tasks;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class QueueController : ControllerBase
    {
        private readonly QueueProcessorService _queueProcessorService;

        public QueueController(QueueProcessorService queueProcessorService)
        {
            _queueProcessorService = queueProcessorService;
        }

        [HttpPost("enqueue")]
        public async Task<IActionResult> EnqueueCustomer([FromBody] QueueRequest request)
        {
            var result = await _queueProcessorService.EnqueueCustomerAsync(request.CustomerId, request.ServiceType);
            return Ok(result);
        }
    }

    public class QueueRequest
    {
        public int CustomerId { get; set; }
        public string ServiceType { get; set; }
    }
}
TokenController.cs
csharp
Copy code
using Microsoft.AspNetCore.Mvc;
using QueueManagementSystem.Models;
using QueueManagementSystem.Services;
using System.Threading.Tasks;

namespace QueueManagementSystem.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TokenController : ControllerBase
    {
        private readonly ApplicationDbContext _context;
        private readonly TokenService _tokenService;

        public TokenController(ApplicationDbContext context, TokenService tokenService)
        {
            _context = context;
            _tokenService = tokenService;
        }

        [HttpPost("create")]
        public async Task<IActionResult> CreateToken([FromBody] Customer customer)
        {
            var token = _tokenService.GenerateJwtToken(customer);
            customer.Token = token;
            _context.Tokens.Add(new Token { Value = token, CustomerId = customer.Id });
            await _context.SaveChangesAsync();

            return Ok(new { Token = token });
        }
    }
}
2. Services
MsmqService.cs
csharp
Copy code
using System.Messaging;
using System.Threading.Tasks;

namespace QueueManagementSystem.Services
{
    public class MsmqService
    {
        private const string QueueName = @".\private$\QueueManagementSystem";

        public async Task EnqueueAsync(QueueItem item)
        {
            using (var queue = new MessageQueue(QueueName))
            {
                var message = new Message
                {
                    Formatter = new XmlMessageFormatter(new[] { typeof(QueueItem).FullName }),
                    Body = item,
                    Label = "QueueItem"
                };

                queue.Send(message);
            }
        }

        public async Task<QueueItem> DequeueAsync()
        {
            using (var queue = new MessageQueue(QueueName))
            {
                var message = queue.Receive();
                var item = (QueueItem)message.Body;
                return item;
            }
        }
    }
}
TokenService.cs
csharp
Copy code
using Microsoft.IdentityModel.Tokens;
using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace QueueManagementSystem.Services
{
    public class TokenService
    {
        private readonly string _secretKey;
        private readonly string _issuer;

        public TokenService(string secretKey, string issuer)
        {
            _secretKey = secretKey;
            _issuer = issuer;
        }

        public string GenerateJwtToken(Customer customer)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(_secretKey);
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(new[]
                {
                    new Claim(ClaimTypes.Name, customer.Name),
                    new Claim(ClaimTypes.NameIdentifier, customer.Id.ToString())
                }),
                Expires = DateTime.UtcNow.AddHours(1),
                Issuer = _issuer,
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
            };

            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }
    }
}
QueueProcessorService.cs
csharp
Copy code
using QueueManagementSystem.Models;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace QueueManagementSystem.Services
{
    public class QueueProcessorService
    {
        private readonly List<QueueItem> _queue = new();

        public Task<QueueResponse> EnqueueCustomerAsync(int customerId, string serviceType)
        {
            // Add to queue with priority
            var customer = new QueueItem { CustomerId = customerId, ServiceType = serviceType, Status = "Pending" };
            _queue.Add(customer);

            // Sort queue by priority (e.g., balance, or some other criteria)
            _queue = _queue.OrderByDescending(c => c.CustomerId).ToList(); // Simplified for demo

            return Task.FromResult(new QueueResponse { Status = "Pending", Message = "Customer enqueued successfully." });
        }

        public Task<QueueItem> DequeueCustomerAsync()
        {
            var item = _queue.FirstOrDefault();
            if (item != null)
            {
                _queue.Remove(item);
                item.Status = "Processed";
            }

            return Task.FromResult(item);
        }
    }

    public class QueueResponse
    {
        public string Status { get; set; }
        public string Message { get; set; }
    }
}
LoggerService.cs
csharp
Copy code
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Services
{
    public class LoggerService
    {
        private readonly ILogger<LoggerService> _logger;

        public LoggerService(ILogger<LoggerService> logger)
        {
            _logger = logger;
        }

        public void LogInfo(string message)
        {
            _logger.LogInformation(message);
        }

        public void LogError(string message)
        {
            _logger.LogError(message);
        }
    }
}
3. Logging
Log4NetProvider.cs
csharp
Copy code
using Microsoft.Extensions.Logging;
using log4net;

namespace QueueManagementSystem.Logging
{
    public class Log4NetProvider : ILoggerProvider
    {
        private readonly ILog _log = LogManager.GetLogger(typeof(Log4NetProvider));

        public ILogger CreateLogger(string categoryName)
        {
            return new Log4NetLogger(_log);
        }

        public void Dispose() { }
    }
}
Log4NetLogger.cs
csharp
Copy code
using log4net;
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem.Logging
{
    public class Log4NetLogger : ILogger
    {
        private readonly ILog _log;

        public Log4NetLogger(ILog log)
        {
            _log = log;
        }

        public IDisposable BeginScope<TState>(TState state) => null;

        public bool IsEnabled(LogLevel logLevel)
        {
            return logLevel switch
            {
                LogLevel.Trace => _log.IsDebugEnabled,
                LogLevel.Debug => _log.IsDebugEnabled,
                LogLevel.Information => _log.IsInfoEnabled,
                LogLevel.Warning => _log.IsWarnEnabled,
                LogLevel.Error => _log.IsErrorEnabled,
                LogLevel.Critical => _log.IsFatalEnabled,
                _ => false,
            };
        }

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)
        {
            if (!IsEnabled(logLevel)) return;

            var message = formatter(state, exception);

            switch (logLevel)
            {
                case LogLevel.Trace:
                case LogLevel.Debug:
                    _log.Debug(message);
                    break;
                case LogLevel.Information:
                    _log.Info(message);
                    break;
                case LogLevel.Warning:
                    _log.Warn(message);
                    break;
                case LogLevel.Error:
                    _log.Error(message);
                    break;
                case LogLevel.Critical:
                    _log.Fatal(message);
                    break;
            }
        }
    }
}
Log4NetExtensions.cs
csharp
Copy code
using Microsoft.Extensions.DependencyInjection;

namespace QueueManagementSystem.Logging
{
    public static class Log4NetExtensions
    {
        public static IServiceCollection AddLog4Net(this IServiceCollection services)
        {
            services.AddSingleton<ILoggerProvider, Log4NetProvider>();
            return services;
        }
    }
}
4. Configuration
appsettings.json
json
Copy code
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=your_server;Database=QueueDb;User Id=your_user;Password=your_password;",
    "LoggingConnection": "Server=your_server;Database=LoggingDb;User Id=your_user;Password=your_password;"
  },
  "Jwt": {
    "SecretKey": "your_secret_key",
    "Issuer": "your_issuer"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  }
}
log4net.config
xml
Copy code
<?xml version="1.0" encoding="utf-8" ?>
<log4net>
  <appender name="FileAppender" type="log4net.Appender.FileAppender">
    <file value="Logs/app.log" />
    <appendToFile value="true" />
    <layout type="log4net.Layout.PatternLayout">
      <conversionPattern value="%date %-5level %logger - %message%newline" />
    </layout>
  </appender>
  <root>
    <level value="DEBUG" />
    <appender-ref ref="FileAppender" />
  </root>
</log4net>
5. Program.cs
csharp
Copy code
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace QueueManagementSystem
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureAppConfiguration((context, config) =>
                {
                    config.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
                    config.AddJsonFile($"appsettings.{context.HostingEnvironment.EnvironmentName}.json", optional: true);
                })
                .ConfigureLogging(logging =>
                {
                    logging.ClearProviders();
                    logging.AddLog4Net("log4net.config");
                })
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                });
    }
}
6. Startup.cs
csharp
Copy code
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using QueueManagementSystem.Data;
using QueueManagementSystem.Logging;
using QueueManagementSystem.Services;
using Microsoft.OpenApi.Models;

namespace QueueManagementSystem
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();
            services.AddDbContext<ApplicationDbContext>(options =>
                options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
            services.AddDbContext<LoggingDbContext>(options =>
                options.UseSqlServer(Configuration.GetConnectionString("LoggingConnection")));

            services.AddSingleton<MsmqService>();
            services.AddSingleton<TokenService>(provider =>
                new TokenService(Configuration["Jwt:SecretKey"], Configuration["Jwt:Issuer"]));
            services.AddSingleton<QueueProcessorService>();
            services.AddSingleton<LoggerService>();

            services.AddLog4Net();

            services.AddSwaggerGen(c =>
            {
                c.SwaggerDoc("v1", new OpenApiInfo { Title = "Queue Management API", Version = "v1" });
            });
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseSwagger();
                app.UseSwaggerUI(c =>
                {
                    c.SwaggerEndpoint("/swagger/v1/swagger.json", "Queue Management API V1");
                    c.RoutePrefix = string.Empty; // Set Swagger UI at the app's root
                });
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                app.UseHsts();
            }

            app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
    }
}
This code setup covers:

JWT Token Generation: Handled by TokenService and TokenController.
MSMQ Queuing: Handled by MsmqService and QueueProcessorService.
Logging: Configured with Log4Net and integrated into the LoggerService.
API Endpoints: Four main controllers for managing cash, loans, account summaries, and queues.
Configuration Files: Includes settings for JWT and logging.
Make sure to adjust connection strings, secret keys, and other sensitive information as needed. Additionally, test thoroughly to ensure all components work together as expected.






